import {
	checkRateLimit,
	getClientIp,
	htmlResponse,
	incrementRateLimit,
} from '@cc-wf-studio-connectors/shared';
import { errorTemplate, installSuccessTemplate, successTemplate } from './templates.js';

/**
 * Environment bindings for the callback handler
 */
export interface CallbackEnv {
	OAUTH_SESSIONS: KVNamespace;
	RATE_LIMIT: KVNamespace;
}

/** Regex for validating session_id (64 character hex string) */
const SESSION_ID_REGEX = /^[a-f0-9]{64}$/;

/** Session TTL: 5 minutes */
const SESSION_TTL_SECONDS = 300;

/**
 * Validate session_id format
 *
 * @param sessionId - Session ID to validate
 * @returns true if valid 64-character hex string
 */
function isValidSessionId(sessionId: unknown): sessionId is string {
	return typeof sessionId === 'string' && SESSION_ID_REGEX.test(sessionId);
}

/**
 * Session data stored in KV
 */
interface SessionData {
	status: 'pending' | 'completed';
	created_at: number;
	code?: string;
}

/**
 * Handle Slack OAuth callback
 *
 * This endpoint receives the authorization code from Slack after user
 * authorizes the app. It handles two scenarios:
 *
 * 1. VSCode flow: Session pre-registered via /slack/init, stores code for polling
 * 2. Direct Slack install: No session, shows installation success message
 *
 * Query params:
 * - code: Authorization code from Slack
 * - state: Session ID generated by VSCode extension (optional for direct install)
 *
 * @param request - Incoming request
 * @param env - Environment bindings
 * @returns HTML response (success or error page)
 */
export async function handleSlackCallback(request: Request, env: CallbackEnv): Promise<Response> {
	const url = new URL(request.url);
	const code = url.searchParams.get('code');
	const state = url.searchParams.get('state');

	// Check for Slack error response
	const error = url.searchParams.get('error');
	if (error) {
		const errorDescription = url.searchParams.get('error_description') ?? 'Unknown error';
		return htmlResponse(errorTemplate(`Slack authorization failed: ${errorDescription}`), 400);
	}

	// Validate required parameters
	if (!code) {
		return htmlResponse(errorTemplate('Missing authorization code'), 400);
	}

	// Rate limiting
	const clientIp = getClientIp(request);
	const rateLimitResult = await checkRateLimit(env.RATE_LIMIT, clientIp, 'callback');

	if (!rateLimitResult.allowed) {
		return htmlResponse(errorTemplate('Too many requests. Please try again later.'), 429);
	}

	await incrementRateLimit(env.RATE_LIMIT, clientIp, 'callback');

	// Case 1: Direct installation from Slack (no valid session state)
	// This happens when users install directly from Slack App Directory
	if (!isValidSessionId(state)) {
		// Show installation success page
		return htmlResponse(installSuccessTemplate());
	}

	// Case 2: VSCode OAuth flow (valid session state)
	// Check if session was pre-registered via /slack/init
	const kvKey = `slack_session:${state}`;
	const existingSession = await env.OAUTH_SESSIONS.get<SessionData>(kvKey, 'json');

	if (!existingSession) {
		// Session expired or not found - treat as direct install
		return htmlResponse(installSuccessTemplate());
	}

	if (existingSession.status !== 'pending') {
		return htmlResponse(
			errorTemplate('Session already used. Please restart the authorization process.'),
			400,
		);
	}

	// Update session with the authorization code
	const updatedSession: SessionData = {
		status: 'completed',
		created_at: existingSession.created_at,
		code: code,
	};

	try {
		await env.OAUTH_SESSIONS.put(kvKey, JSON.stringify(updatedSession), {
			expirationTtl: SESSION_TTL_SECONDS,
		});
	} catch (err) {
		console.error('Failed to store OAuth session:', err);
		return htmlResponse(errorTemplate('Failed to process authorization. Please try again.'), 500);
	}

	// Return success page for VSCode flow
	return htmlResponse(successTemplate());
}
