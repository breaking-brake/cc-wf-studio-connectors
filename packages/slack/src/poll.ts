import {
	checkRateLimit,
	getClientIp,
	incrementRateLimit,
	jsonResponse,
	withCors,
} from '@cc-wf-studio-connectors/shared';

/**
 * Environment bindings for the poll handler
 */
export interface PollEnv {
	OAUTH_SESSIONS: KVNamespace;
	RATE_LIMIT: KVNamespace;
}

/** Regex for validating session_id (64 character hex string) */
const SESSION_ID_REGEX = /^[a-f0-9]{64}$/;

/**
 * Validate session_id format
 *
 * @param sessionId - Session ID to validate
 * @returns true if valid 64-character hex string
 */
function isValidSessionId(sessionId: unknown): sessionId is string {
	return typeof sessionId === 'string' && SESSION_ID_REGEX.test(sessionId);
}

/**
 * Session data stored in KV
 */
interface SessionData {
	status: 'pending' | 'completed';
	created_at: number;
	code?: string;
}

/**
 * Poll response type
 */
interface PollResponse {
	status: 'success' | 'pending' | 'expired';
	code?: string;
	message?: string;
}

/**
 * Handle poll request from VSCode extension
 *
 * This endpoint is polled by the VSCode extension to check if the user
 * has completed the OAuth authorization. Once the code is retrieved,
 * it is deleted from KV (one-time use).
 *
 * Query params:
 * - session: Session ID generated by VSCode extension
 *
 * @param request - Incoming request
 * @param env - Environment bindings
 * @returns JSON response with poll status
 */
export async function handleSlackPoll(request: Request, env: PollEnv): Promise<Response> {
	const url = new URL(request.url);
	const sessionId = url.searchParams.get('session');

	// Validate session ID
	if (!isValidSessionId(sessionId)) {
		const response: PollResponse = {
			status: 'expired',
			message: 'Invalid session ID',
		};
		return withCors(jsonResponse(response, 400));
	}

	// Rate limiting
	const clientIp = getClientIp(request);
	const rateLimitResult = await checkRateLimit(env.RATE_LIMIT, clientIp, 'poll');

	if (!rateLimitResult.allowed) {
		const response: PollResponse = {
			status: 'expired',
			message: 'Too many requests. Please try again later.',
		};
		return withCors(jsonResponse(response, 429));
	}

	await incrementRateLimit(env.RATE_LIMIT, clientIp, 'poll');

	// Try to retrieve the session
	const kvKey = `slack_session:${sessionId}`;

	try {
		const session = await env.OAUTH_SESSIONS.get<SessionData>(kvKey, 'json');

		if (!session) {
			// Session not found - expired or never existed
			const response: PollResponse = {
				status: 'expired',
				message: 'Session not found or expired',
			};
			return withCors(jsonResponse(response, 410));
		}

		if (session.status === 'pending') {
			// Session exists but OAuth not completed yet
			const response: PollResponse = {
				status: 'pending',
				message: 'Authorization not completed yet',
			};
			return withCors(jsonResponse(response, 404));
		}

		if (session.status === 'completed' && session.code) {
			// Session completed - return the code and delete from KV (one-time use)
			await env.OAUTH_SESSIONS.delete(kvKey);

			const response: PollResponse = {
				status: 'success',
				code: session.code,
			};
			return withCors(jsonResponse(response, 200));
		}

		// Unexpected state
		const response: PollResponse = {
			status: 'expired',
			message: 'Invalid session state',
		};
		return withCors(jsonResponse(response, 500));
	} catch (err) {
		console.error('Failed to retrieve OAuth session:', err);
		const response: PollResponse = {
			status: 'expired',
			message: 'Failed to retrieve session',
		};
		return withCors(jsonResponse(response, 500));
	}
}
